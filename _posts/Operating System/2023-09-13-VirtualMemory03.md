---
layout: single
title: "13) 가상 메모리 Part.03"
categories: OperatingSystem
tag: [Operating System, Virtual Memory]
permalink : /posts/OS-13/
toc: true
classes: custom-style
author_profile: false
sidebar:
  nav: "OperatingSystem"
---

<hr>

# 요구 페이징

요구 페이징<sup>demand paging</sup>: 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법(**실행에 요구되는 페이지만 적재하는 기법**)

1. CPU가 특정 페이지에 접근하는 명령어를 실행
2. 유효 비트가 1일 경우 CPU는 페이지가 적재된 프레임에 접근
3. 유효 비트가 0일 경우 페이지 폴트가 발생
4. **페이지 폴트 처리 루틴**은 해당 페이지를 메모리에 적재하고 유효 비트를 1로 설정
5. 다시 1번을 수행

## 순수 요구 페이징

순수 요구 페이징<sup>pure demand paging</sup>: 아무런 페이지도 메모리에 적재하지 않고 *무작정 실행*시키는 방식으로 *첫 명령어를 실행하는 순간부터 페이지 폴트가 발생*하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어짐

# 페이지 교체와 프레임 할당

요구 페이징 시스템이 안정적으로 작동하려면 필연적으로 다음 두 가지를 해결해야 합니다.

운영체제는 어떻게 기존 메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보낼 수 있는지(**페이지 교체**)

그리고 프로세스들에 얼마만큼의 프레임을 할당할 것인가(**프레임 할당**)

## 페이지 교체 알고리즘

요구 페이징에 의해 페이지가 메모리에 가득 찰 경우 어떤 페이지를 보조기억장치에 내보낼 것인가를 결정하는 알고리즘

- 일반적으로 페이지 폴트가 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가

> 메모리에 적재된 페이지를 가져오는 것보다 보조기억장치에 적재된 페이지를 가져오는 것이 훨씬 느림 

- 가령 자주 사용되는 페이지를 스왑 아웃 시킨다면 계속해서 페이지 폴트가 발생할 것이다(나쁜 알고리즘)

어떠한 페이지 교체 알고리즘이 좋은 알고리즘인지 판단하려면 **페이지 폴트 횟수**를 알아야 하며, 페이지 폴트 횟수는 **페이지 참조열**<sup>page reference string</sup>을 통해 알 수 있습니다.

- 페이지 참조열: CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열

- 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문에 연속되는 페이지를 생략

### FIFO 페이지 교체 알고리즘

- FIFO 페이지 교체 알고리즘(**First-In First-Out** Page Replacement Algorithm)

- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식

### 최적 페이지 교체 알고리즘

### LRU 페이지 교체 알고리즘


