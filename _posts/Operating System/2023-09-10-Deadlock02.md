---
layout: single
title: "10) 교착 상태 Part.02"
categories: OperatingSystem
tag: [Operating System, Dead Lock]
permalink : /posts/OS-10/
toc: true
classes: custom-style
author_profile: false
sidebar:
  nav: "OperatingSystem"
---

<hr>

# 교착 상태 해결 방법

교착 상태 해결 방법에는 **교착 상태 예방**, **교착 상태 회피**, **교착 상태 검출 후 회복**이 있음

## 교착 상태 예방

교착 상태 발생 조건 네 가지 중 하나를 충족하지 못하게 하는 방법

### 상호 배제 제거 방식

- 상호 배제를 제거하면 프로세스들이 모든 자원을 공유하게 되므로 현실적이지 않은 방식

> 프로세스들의 동기화가 이루어 지지 않고, 프린터도 동시에 사용하는 등 문제가 발생

### 점유와 대기 제거 방식

- 점유와 대기를 없애면 운영체제는 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분함

- 자원을 몰아주는 방식이 되기 때문에 자원의 활용율이 낮아짐

- 동시에 많은 자원을 필요로 하는 프로세스는 자원을 사용할 타이밍을 확보하기 어려워 기아 현상[^1]을 야기할 우려가 있음

[^1]: 기아 현상 : 우선순위가 낮은 프로세스는 계속해서 실행이 연기되는 현상

### 비선점 조건 제거 방식

- 비선점 조건을 없애면 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음

- CPU 자원에는 효과적이지만, 다른 자원에는 맞지 않아 범용성이 떨어지는 방안

> 예시 : 한 프로세스가 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗으면 안됨

### 원형 대기 조건 제거 방식

- 모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당하면 원형 대기는 발생하지 않음

- 앞선 세 방식에 비하면 비교적 현실적이고 실용적인 방식

- 단점 : 수많은 자원에 번호를 붙이는 것이 어려우며, 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음

## 교착 상태 회피

프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법

### 교착 상태 회피 주요 용어

1. **안전 순서열**<sup>safe sequence</sup> : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서

2. **안전 상태**<sup>safe state</sup> : 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태(*안전 순서열이 있는 상태*)

3. **불안전 상태**<sup>unsafe state</sup> : 교착 상태가 발생할 수도 있는 상태(*안전 순서열이 없는 상태*)

### 교착 상태 회피 예시

#### 안전 순서열이 있는 상태

1. 세 개의 프로세스(P1, P2, P3)와 12개의 할당 가능한 자원이 있다고 가정

  ```
  - 현재 P1 프로세스는 5개의 자원을 사용하고 있으며, 추가로 5개의 자원을 요청 하였음
  - 현재 P2 프로세스는 2개의 자원을 사용하고 있으며, 추가로 2개의 자원을 요청 하였음  
  - 현재 P3 프로세스는 2개의 자원을 사용하고 있으며, 추가로 7개의 자원을 요청 하였음
  ```

2. 현재 총 9개의 자원이 사용 중이므로, 사용 가능한 자원은 3개

  ```
  - 총 할당 가능한 자원   : 12개
  - P1 프로세스 사용 자원 :  5개
  - P2 프로세스 사용 자원 :  2개
  - P3 프로세스 사용 자원 :  2개
  - 현재 사용 가능한 자원 :  3개
  ```

  > 현재 사용 가능한 자원을 X로 표기

3. *P2 프로세스*가 요청한 자원이 사용 가능한 자원보다 작으므로 P2 프로세스가 먼저 자원을 할당 받음 (X : 3 => 1)

4. P2 프로세스의 작업이 완료 된 후, P2 프로세스가 기지고 있던 4개의 자원을 반환 (X : 1 => 5)

5. *P1 프로세스*의 요청한 자원이 5개이므로 그다음 순서로 P1이 자원을 할당 받음 (X : 5 => 0)

6. P1 프로세스의 작업이 완료 된 후, P1 프로세스가 가지고 있던 10개의 자원을 반환 (x : 0 => 10)

7. 마지막으로 7개의 자원을 요청한 *P3 프로세스*에 자원을 할당(x : 10 => 3)하고 작업 종료 후 가지고 있던 9개의 자원을 반환(x : 3 => 12)

8. **안전 순서열은 P2 -> P1 -> P3 이다.**

#### 안전 순서열이 없는 상태

1. 세 개의 프로세스(P1, P2, P3)와 12개의 할당 가능한 자원이 있다고 가정

  ```
  - 현재 P1 프로세스는 5개의 자원을 사용하고 있으며, 추가로 7개의 자원을 요청 하였음
  - 현재 P2 프로세스는 2개의 자원을 사용하고 있으며, 추가로 2개의 자원을 요청 하였음  
  - 현재 P3 프로세스는 2개의 자원을 사용하고 있으며, 추가로 7개의 자원을 요청 하였음
  ```

2. 현재 총 9개의 자원이 사용 중이므로, 사용 가능한 자원은 3개

3. P2 프로세스가 먼저 추가로 2개의 자원을 할당(X : 3 => 1) 받고 작업 완료 후 4개의 자원을 반환 (X : 1 => 5)

4. P1과 P3 프로세스 모두 추가로 7개의 자원을 필요로 하지만, 현재 사용 가능한 자원은 5개로 P1과 P3는 자원을 사용할 수 없음(<u>안전 순서열이 없는 불안전 상태. 교착 상태에 빠질 위험이 있음</u>)

### 결론

교착 상태 회피는 안전 상태를 유지하도록(안전 순서열이 있도록) 자원을 할당하는 방식

## 교착 상태 검출 후 회복

프로세스들이 자원을 요구할 때마다 그때그때 자원을 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사하며, 교착 상태 발생 시 다음과 같은 방법으로 회복시키는 방식

### 선점을 통한 회복

- 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식

- 다른 프로세스의 자원을 빼앗고 한 프로세스에 할당

### 프로세스 강제 종료를 통한 회복

- 교착 상태가 발생한 프로세스를 강제로 종료하는 방식으로 단순하면서 확실한 방식

- 교착 상태가 발생한 프로세스를 모두 종료 : 확실한 방식이지만, 많은 프로세스들의 작업 내역을 잃을 수 있음

- 교착 상태가 발생한 프로세스를 하나씩 종료 : 작업 내역을 잃는 프로세스를 줄일 수 있지만, 교착 상태가 없어졌는지 여부를 확인하는 과정에서 오버헤드를 야기

## 타조 알고리즘

- 교착 상태를 무시하는 방법